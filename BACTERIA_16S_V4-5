##################### BACTERIA 16S V4-5, obtenidas desde IMR-Sequencing, CA. #####################
##################### Recopilado por LK - Septiembre, 2016 #######################################

#Recordar tener el mismo directorio: Ejecutable Mothur.exe y Uchime.exe; las bases de datos que quiera usar para asignar, todos los archivos de secuenciación y el archivo con los nombres de las muestras. Hacer archivo con los nombres de las muestras y sus respectivos archivos de secuenciación: Nombrarlo nombreX.files.txt para modificarlo y cuando este listo eliminar el .txt

#Para hacer los contigs usar el siguiente comando (en mi caso con dos procesadores porque es lo que hay):
make.contigs(file=seasonality.files, processors=2)

#Chequear los resultados del ensamblaje de los contigs usando: 
summary.seqs(fasta=seasonality.trim.contigs.fasta)

#En nuestro caso las secuencias deberían variar entre 400-500 bp pero si tenemos máximos y mínimos muy distintos a esos y además tenemos ambigüedades en el 2.5% de nuestras muestras entonces corremos para limpiarlas:
screen.seqs(fasta=seasonality.trim.contigs.fasta, group=seasonality.contigs.groups, maxambig=0, maxlength=500)

#Para eliminar las secuencias que puedan ser por error del computador debido al alineamiento: 
unique.seqs(fasta=seasonality.trim.contigs.good.fasta)

#Para facilitar la vida después, se hace una tabla con el numero de veces que cada secuencia única se encuentra en cada grupo: filas, nombre de la secuencia; columna, nombre del grupo.
count.seqs(name=seasonality.trim.contigs.good.names, group=seasonality.contigs.good.groups)

#Y veo los resultados de la cuenta con:
summary.seqs(count=seasonality.trim.contigs.good.count_table)

#Para hacer el alineamiento con la base de datos mas rápido la idea es acotarla al segmento que amplificamos, con:
pcr.seqs(fasta=silva.bacteria.fasta, start=11894, end=42000, keepdots=F, processors=2)

system(rename silva.bacteria.pcr.fasta silva.v4.fasta)

summary.seqs(fasta=silva.v4.fasta)

#Ahora ya puedo alinear las secuencias (voy a intentar a ver si funciona con el rango que le di =P)
align.seqs(fasta=seasonality.trim.contigs.good.unique.fasta, reference=silva.v4.fasta)

#Y se vuelve a revisar como quedo con:
summary.seqs(fasta=seasonality.trim.contigs.good.unique.align, count=seasonality.trim.contigs.good.count_table)

#Para asegurarnos que están alineando en el mismo segmento :
screen.seqs(fasta=seasonality.trim.contigs.good.unique.align, count=seasonality.trim.contigs.good.count_table, summary=seasonality.trim.contigs.good.unique.summary, start=1968, end=11550, maxhomop=8)

#Para ver como quedo: 
summary.seqs(fasta=current, count=current)

#Luego, eliminamos los gaps (-) de la tabla para solo quedarnos con los que tienen valores.
filter.seqs(fasta=seasonality.trim.contigs.good.unique.good.align, vertical=T, trump=.)

#Revisamos nuevamente que solo hayan secuencias únicas:
unique.seqs(fasta=seasonality.trim.contigs.good.unique.good.filter.fasta, count=seasonality.trim.contigs.good.good.count_table)

#Se hace un pre-cluster para unir secuencias que puedan tener hasta 2 nt de diferencia.
pre.cluster(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.fasta, count=seasonality.trim.contigs.good.unique.good.filter.count_table, diffs=2) 

#De acuerdo al pipeline del Lab:
split.abund(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.fasta, count=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.count_table, cutoff=1, accnos=true)

#Para identificar y eliminar las quimeras del .count_table:
chimera.uchime(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.fasta, count=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.count_table, dereplicate=t)	

#Para eliminarlas luego del fasta:
remove.seqs(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.fasta, accnos=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.uchime.accnos) 

#Para ver con que nos quedamos luego de eliminarlas:
summary.seqs(fasta=current, count=current)

#Clasificamos las secuencias para asegurarnos de que solo tenemos secuencias de 16S de Bacteria:
classify.seqs(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.fasta, count=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.uchime.pick.count_table, reference=trainset9_032012.pds.fasta, taxonomy=trainset9_032012.pds.tax, cutoff=80)  

#Entonces ahora se eliminan las que no nos interesan:
remove.lineage(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.fasta, count=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.uchime.pick.count_table, taxonomy=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.pds.wang.taxonomy, taxon=Chloroplast-Mitochondria-unknown-Archaea-Eukaryota) 

#Para ver lo que obtuvimos:
summary.seqs(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.fasta, count=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.uchime.pick.count_table)

#Ahora finalmente podemos hacer cluster con OTU’s yey!!
dist.seqs(fasta=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.pick.fasta, cutoff=0.1, processors=2) 		

cluster(column=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.pick.dist, count=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.uchime.pick.pick.count_table)

#Hay que determinar cuantas secuencias hay en cada OTU de cada grupo.
make.shared(list=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.pick.an.unique_list.list, count=seasonality.cut.trim.contigs.good.unique.good.filter.unique.precluster.abund.uchime.pick.pick.count_table, label=0.03)

#Para clasificar las OTUs
classify.otu(list=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.pick.an.unique_list.list, count=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.uchime.pick.pick.count_table, taxonomy=seasonality.trim.contigs.good.unique.good.filter.unique.precluster.abund.pick.pds.wang.pick.taxonomy, label=0.03)


### CON ESO YA DEBERIAMOS PODER JUGAR CON LOS ANÁLISIS!
